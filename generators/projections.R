## Test projections on a density
## Given a symmetric, positive-semidefinite matrix rho
## the projection on a fuzzy subspace A is A^1/2 rho A^1/2 (normalised so that trace is 1)

## Builds rho and A

N <- 10
AN <- 3
rhoN <- 5

# N: dimension of space
# AN: number of vectors used to generate A
# rhoN: number of vectors used to generate rho
# seed: the random seed
generate <- function(N, AN, rhoN, seed=0) {
  
  ## Builds a positive-semidefinite matrix creating vectors
  ## n is the number of vectors, N is the dimension of the vectors
  ## sparsity is the sparcity level
  build <-  function (n, N, sparcity) {
    V <- vector("list", n)

    ## Creates a vector
    N2 <- trunc((1-sparcity) * N)
    A <- matrix(0,nrow=N,ncol=N)
    for(i in 1:n) {
      v <- numeric(N)
      v[sample(N, N2)] <- rnorm(N2)
      V[[i]] <- v
      A <- A + v %o% v
    }

    # Normalises
    A <- A / sum(diag(A))
    list(vectors=V, m=A)
  }


  set.seed(seed)
  rho <- build(rhoN,N,0)
  A <- build(AN,N,.5)

  ## Computes the projections (fuzzy and not fuzzy)

  ## Computes the subspace A
  dA <- eigen(A$m)

  # Clean-up small values
  dA$values[dA$values < 1e-16 * max(dA$values)] <- 0
  
  # sqrt(A)
  sqrtA <- dA$vectors %*% diag(dA$values^.5) %*% t(dA$vectors)
  idx <- dA$values > 0
 
  ## Projector on A (discard null values)
  pA <- dA$vectors[,idx] %*% t(dA$vectors[,idx])

  # fpRho =p= A^1/2 rho A^1/2 [fuzzy projection]
  fpRho <- sqrtA %*% rho$m %*% sqrtA; fpRho <- fpRho / sum(diag(fpRho))

  # pRho =p= pA %*% rho$m %*% pA [projection]
  pRho <-  pA %*% rho$m %*% pA; pRho <- pRho / sum(diag(pRho))

  prjRho <- list( fuzzy = fpRho, strict = pRho)

  ## Compute fuzzy orthogonals
  doA <- eigen(diag(N) - A$m)
  doA$values[doA$values < 0] <- 0
  sqrtoA <- doA$vectors %*% diag(doA$values^.5) %*% t(doA$vectors)
  opA <- diag(N) - pA

  fpRho <- sqrtoA %*% rho$m %*% sqrtoA; fpRho <- fpRho / sum(diag(fpRho))
  pRho <-  opA %*% rho$m %*% opA; pRho <- pRho / sum(diag(pRho))

  oprjRho <- list( fuzzy = fpRho, strict = pRho)

  ## Outputs for java
  catMatrix <- function(name, m) {
    
    cat("Eigen::MatrixXd ",name, "(", nrow(m),", ",ncol(m),");\n",name," << ",sep="")
    for(i in 1:nrow(m)) {    
      for(j in 1:ncol(m)) {
        if (i > 1 || j > 1) cat(", ");
        cat(m[i,j]);
      }
    }
    cat(";\n");
  }

  catVector <- function(v) {
    for(i in 1:length(v)) {    
      if (i > 1) cat(", ");
      cat(v[i]);
    }
  }

  catVectors <- function(name, V) {
    cat("std::vector<Eigen::VectorXd>  ",name, "(", length(V), ");\n");

    for(i in 1:length(V)) {
      cat(name,"[",i-1,"].resize(", length(V[[i]]) ,");\n");    
      cat(name,"[",i-1,"] << ");
      catVector(V[[i]]);
      cat(";\n");
    }
    cat("\n");
  }

  cat("// DO NOT EDIT\n//Generated by projections.R\n\n");
  cat("int dimension =", N,";\n");
  cat("int sbVectorsCount =", AN,";\n");
  cat("int rhoVectorsCount =", rhoN,";\n");
  cat("\n\n");

  catVectors("rhoVectors", rho$vectors);
  catVectors("sbVectors", A$vectors);

  catMatrix("wanted_fpRho", prjRho$fuzzy); cat("\n");
  catMatrix("wanted_pRho",prjRho$strict); cat("\n");

  catMatrix("wanted_ofpRho", oprjRho$fuzzy); cat("\n");
  catMatrix("wanted_opRho",oprjRho$strict); cat("\n");
}

generate(10,3,5,10)
